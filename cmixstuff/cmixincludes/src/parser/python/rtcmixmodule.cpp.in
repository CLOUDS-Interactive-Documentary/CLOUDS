// This file generated by the "make_python_ext.pl" script.  Don't edit here!

/* RTcmix - Copyright (C) 2004  The RTcmix Development Team
   See ``AUTHORS'' for a list of contributors. See ``LICENSE'' for
   the license to this software and for a DISCLAIMER OF ALL WARRANTIES.
*/

/* This Python extension has two purposes.

      1. It lets a Python script call RTcmix functions, when RTcmix
         embeds the Python interpreter.

      2. It lets a Python script use variables that refer to RTcmix
         Handles, which contain references to PField and other
         future types of object.  Some of the arithmetic operators
         are overloaded for use with these objects.

   The module is called "rtcmix"; the object is called OpaqueObject,
   which wraps an RTcmix RtcHandle.  Some RTcmix functions return a
   RtcHandle to the script.

   The code here is based on the previous RTcmix python extension,
   the example code in "xxmodule.c" in the Python distribution, and
   the skpoint.c module code in skencil-0.6.16, a GPL'd drawing
   program largely written in Python.
                                                John Gibson, 7/4/04
*/

#include "Python.h"
#if defined(PY_MAJOR_VERSION) && PY_VERSION_HEX < 0x02010000
#error "******** You need Python 2.1 or greater ********"
#endif

#include <rtcmix_types.h>
#include <PField.h>
#include <utils.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "../../include/maxdispargs.h"
#include "../../rtcmix/prototypes.h"
#include "../../rtcmix/RTcmix.h"

static PyObject *ErrorObject;


// -- Opaque object -----------------------------------------------------------

typedef struct {
   PyObject_HEAD
   PyObject *attrDict;    // Attributes dictionary
   RtcHandle handle;
} OpaqueObject;

//staticforward PyTypeObject OpaqueType;
extern PyTypeObject OpaqueType;

//#define OpaqueObject_Check(obj) ((obj)->ob_type == &OpaqueType)
inline bool OpaqueObject_Check(PyObject *obj)
{
   return (obj->ob_type == &OpaqueType);
}

static OpaqueObject *newOpaqueObject(PyObject *arg)
{
   OpaqueObject *self = PyObject_NEW(OpaqueObject, &OpaqueType);
   if (self == NULL)
      return NULL;

   self->attrDict = NULL;
   self->handle = NULL;

   return self;
}

static void Opaque_dealloc(OpaqueObject *self)
{
// printf("Opaque_dealloc: %p\n", self);
   if (self->handle)
      unrefHandle(self->handle);
   Py_XDECREF(self->attrDict);
   PyObject_Del(self);
}


// Return a RtcHandle from a PyObject, which MUST be an OpaqueObject.
inline RtcHandle HandleFromPyObject(PyObject *obj)
{
   return ((OpaqueObject *) obj)->handle;
}


// Return a PField from a PyObject, or NULL if the object does not represent
// either a PField RtcHandle or a number.
static PField *PFieldFromPyObject(PyObject *obj)
{
   PField *pfield;
   if (OpaqueObject_Check(obj)) {
      RtcHandle handle = HandleFromPyObject(obj);
      if (handle->type != PFieldType) {
         PyErr_SetString(PyExc_TypeError,
                           "can't operate on a RtcHandle that is not a PField");
         return NULL;
      }
      pfield = (PField *) handle->ptr;
   }
   else {
      if (!PyNumber_Check(obj)) {
         PyErr_SetString(PyExc_TypeError,
                         "can operate only with PField Handles and numbers.");
         return NULL;
      }
      double val = PyFloat_AsDouble(obj);
      pfield = new ConstPField(val);
   }
   return pfield;
}


// -- Opaque object methods ---------------------------------------------------

/* This is where to write methods that could be called on our Opaque object:
   maybe ways to see what type it is, its values, etc.
   This is NOT the place to list rtcmix functions (see _rtcmix_methods below).
*/

static PyObject *Opaque_type(OpaqueObject *self, PyObject *args)
{
   const char *str = NULL;

   if (!PyArg_ParseTuple(args, ":type"))
      return NULL;
   
   RtcHandle handle = HandleFromPyObject((PyObject *) self);
   if (handle->type == PFieldType)
      str = "PField";
   else if (handle->type == InstrumentPtrType)
      str = "Instrument";
   else if (handle->type == AudioStreamType)
      str = "AudioStream";
   else
      str = "(invalid)";
   return PyString_FromString(str);
}

static PyMethodDef Opaque_methods[] = {
   {"type", (PyCFunction) Opaque_type, METH_VARARGS},
   {NULL, NULL}      // sentinel
};

static PyObject *Opaque_getattr(OpaqueObject *self, const char *name)
{
   if (self->attrDict != NULL) {
      PyObject *obj = PyDict_GetItemString(self->attrDict, name);
      if (obj != NULL) {
         Py_INCREF(obj);
         return obj;
      }
   }
   return Py_FindMethod(Opaque_methods, (PyObject *) self, (char *) name);
}

static int Opaque_setattr(OpaqueObject *self, const char *name, PyObject *obj)
{
   if (self->attrDict == NULL) {
      self->attrDict = PyDict_New();
      if (self->attrDict == NULL)
         return -1;
   }
   if (obj == NULL) {
      int rv = PyDict_DelItemString(self->attrDict, name);
      if (rv < 0)
         PyErr_SetString(PyExc_AttributeError,
                         "delete non-existing Opaque attribute");
      return rv;
   }
   else
      return PyDict_SetItemString(self->attrDict, name, obj);
}


// -- Opaque object number methods --------------------------------------------

static double plus_binop(double x, double y) { return x + y; }
static double minus_binop(double x, double y) { return x - y; }
static double mult_binop(double x, double y) { return x * y; }
static double divide_binop(double x, double y) { return (y != 0.0)
                                             ? x / y : 999999999999999999.9; }
static double mod_binop(double x, double y) { return fmod(x, y); }
static double pow_binop(double x, double y) { return pow(x, y); }

typedef enum {
   OpPlus,
   OpMinus,
   OpMul,
   OpDiv,
   OpMod,
   OpPow,
   OpNeg
} NumberOp;


// Create and return appropriate binary operator PField
static PField *createBinopPField(PField *pfield1, PField *pfield2, NumberOp op)
{
   PFieldBinaryOperator::Operator binop = NULL;
  
   switch (op) {
      case OpPlus:
         binop = plus_binop;
         break;
      case OpMinus:
         binop = minus_binop;
         break;
      case OpMul:
         binop = mult_binop;
         break;
      case OpDiv:
         binop = divide_binop;
         break;
      case OpMod:
         binop = mod_binop;
         break;
      case OpPow:
         binop = pow_binop;
         break;
      case OpNeg:
         binop = mult_binop;  // assumes one pfield is ConstPField w/ val == -1
         break;
      default:
         assert("invalid binary handle operator");
         return NULL;
   }
   return new PFieldBinaryOperator(pfield1, pfield2, binop);
}


static PyObject *
_do_numop(PyObject *a, PyObject *b, NumberOp op)
{
   PField *pfield1 = PFieldFromPyObject(a);
   PField *pfield2 = PFieldFromPyObject(b);
   if (pfield1 == NULL || pfield2 == NULL) {
      Py_INCREF(Py_NotImplemented);
      return Py_NotImplemented;
   }

   PField *opfield = createBinopPField(pfield1, pfield2, op);

   OpaqueObject *newobj = newOpaqueObject(NULL);
   if (newobj == NULL) {
      PyErr_SetString(PyExc_TypeError, "can't allocate new RtcHandle");
      Py_INCREF(Py_NotImplemented);
      return Py_NotImplemented;
   }
   newobj->handle = createPFieldHandle(opfield);

   return (PyObject *) newobj;
}


static PyObject *
Opaque_add(PyObject *a, PyObject *b)
{
   return _do_numop(a, b, OpPlus);
}

static PyObject *
Opaque_subtract(PyObject *a, PyObject *b)
{
   return _do_numop(a, b, OpMinus);
}

static PyObject *
Opaque_multiply(PyObject *a, PyObject *b)
{
   return _do_numop(a, b, OpMul);
}

static PyObject *
Opaque_divide(PyObject *a, PyObject *b)
{
   return _do_numop(a, b, OpDiv);
}

static PyObject *
Opaque_remainder(PyObject *a, PyObject *b)
{
   return _do_numop(a, b, OpMod);
}

#ifdef NOTYET
static PyObject *
Opaque_divmod(PyObject *a, PyObject *b)
{
   // FIXME: should return 2-tuple of (quotient, remainder)?
}
#endif

static PyObject *
Opaque_power(PyObject *a, PyObject *b, PyObject *c)
{
   // FIXME: <c> is optional modulo, which we ignore here
   return _do_numop(a, b, OpPow);
}

static PyObject *
Opaque_neg(PyObject *a)
{
   if (!OpaqueObject_Check(a)) {          // not sure how this could happen
      Py_INCREF(Py_NotImplemented);
      return Py_NotImplemented;
   }

   RtcHandle handle = HandleFromPyObject(a);
   if (handle->type != PFieldType) {
      PyErr_SetString(PyExc_TypeError,
                        "can't negate a RtcHandle that is not a PField");
      return NULL;
   }

   PField *pfield1 = (PField *) handle->ptr;
   PField *pfield2 = new ConstPField(-1.0);
   PField *opfield = createBinopPField(pfield1, pfield2, OpMul);

   OpaqueObject *newobj = newOpaqueObject(NULL);
   if (newobj == NULL) {
      PyErr_SetString(PyExc_TypeError, "can't allocate new RtcHandle");
      Py_INCREF(Py_NotImplemented);
      return Py_NotImplemented;
   }
   newobj->handle = createPFieldHandle(opfield);

   return (PyObject *) newobj;
}

static PyObject *
Opaque_not_implemented(void)
{
   PyErr_SetString(PyExc_TypeError, "operator not implemented for RtcHandle");
   Py_INCREF(Py_NotImplemented);
   return Py_NotImplemented;
}


static PyNumberMethods Opaque_as_number = {
   (binaryfunc) Opaque_add,                  // nb_add
   (binaryfunc) Opaque_subtract,             // nb_subtract
   (binaryfunc) Opaque_multiply,             // nb_multiply
   (binaryfunc) Opaque_divide,               // nb_divide
   (binaryfunc) Opaque_remainder,            // nb_remainder
   (binaryfunc) Opaque_not_implemented,      // nb_divmod
   (ternaryfunc) Opaque_power,               // nb_power
   (unaryfunc) Opaque_neg,                   // nb_negative
   (unaryfunc) Opaque_not_implemented,       // nb_positive
   (unaryfunc) Opaque_not_implemented,       // nb_absolute
   (inquiry) Opaque_not_implemented,         // nb_nonzero
   (unaryfunc) 0,                            // nb_invert
   (binaryfunc) 0,                           // nb_lshift
   (binaryfunc) 0,                           // nb_rshift
   (binaryfunc) 0,                           // nb_and
   (binaryfunc) 0,                           // nb_xor
   (binaryfunc) 0,                           // nb_or
   0,                                        // nb_coerce
   (unaryfunc) 0,                            // nb_int
   (unaryfunc) 0,                            // nb_long
   (unaryfunc) 0,                            // nb_float
   (unaryfunc) 0,                            // nb_oct
   (unaryfunc) 0,                            // nb_hex
};

//statichere PyTypeObject OpaqueType = {
PyTypeObject OpaqueType = {
   /* The ob_type field must be initialized in the module init function
      to be portable to Windows without using C++.
   */
   PyObject_HEAD_INIT(NULL) 0,   // ob_size
   "rtcmixmodule.Opaque",        // tp_name
   sizeof(OpaqueObject),         // tp_basicsize
   0,                            // tp_itemsize
   // methods
   (destructor) Opaque_dealloc,  // tp_dealloc
   0,                            // tp_print
   (getattrfunc) Opaque_getattr, // tp_getattr
   (setattrfunc) Opaque_setattr, // tp_setattr
   0,                            // tp_compare
   0,                            // tp_repr
   &Opaque_as_number,            // tp_as_number
   0,                            // tp_as_sequence
   0,                            // tp_as_mapping
   0,                            // tp_hash
   0,                            // tp_call
   0,                            // tp_str
   0,                            // tp_getattro
   0,                            // tp_setattro
   0,                            // tp_as_buffer
   Py_TPFLAGS_CHECKTYPES,        // tp_flags
   0,                            // tp_doc
   0,                            // tp_traverse
   0,                            // tp_clear
   0,                            // tp_richcompare
   0,                            // tp_weaklistoffset
   0,                            // tp_iter
   0,                            // tp_iternext
   0,                            // tp_methods
   0,                            // tp_members
   0,                            // tp_getset
   0,                            // tp_base
   0,                            // tp_dict
   0,                            // tp_descr_get
   0,                            // tp_descr_set
   0,                            // tp_dictoffset
   0,                            // tp_init
   0,                            // tp_alloc
   0,                            // tp_new
   0,                            // tp_free
   0,                            // tp_is_gc
};


// -- rtcmix module -----------------------------------------------------------

static PyObject *_call_dispatch(PyObject *args, const char *funcname)
{
   if (!PyTuple_Check(args))
      return NULL;

   int nargs = PyTuple_Size(args);
   if (nargs > MAXDISPARGS) {
      char buf[128];
      sprintf(buf, "too many arguments to '%s'", funcname);
      PyErr_SetString(PyExc_TypeError, buf);
      return NULL;
   }

   Arg *rtcmixargs = new Arg[nargs];
   if (rtcmixargs == NULL)
      return NULL;

   for (int i = 0; i < nargs; i++) {
      PyObject *obj = PyTuple_GET_ITEM(args, i);
      if (OpaqueObject_Check(obj)) {
         RtcHandle handle = HandleFromPyObject(obj);
         if (handle->type != PFieldType) {
            PyErr_SetString(PyExc_TypeError, "can't use non-PField RtcHandle");
            return NULL;
         }
         rtcmixargs[i] = handle;
      }
      else if (PyNumber_Check(obj)) {
         double val = PyFloat_AsDouble(obj);
         rtcmixargs[i] = val;
#ifdef DEBUG
         printf("%d: %8f\n", i, val);
#endif
      }
      else if (PyString_Check(obj)) {
         // dup the string, because we'll kill interpreter before
         // insts have run.
// FIXME: leak -- not necessary, because StringPField dups string?
         char *str = strdup(PyString_AS_STRING(obj));
         rtcmixargs[i] = str;
#ifdef DEBUG
         printf("%d: \"%s\"\n", i, str);
#endif
      }
      // NOTE: The memory allocated below is free'd right after the dispatch
      // call, during "delete rtcmixargs" (in Arg::~Arg).  Hopefully, cmix
      // functions will _copy_ the array contents.
      else if (PyTuple_Check(obj)) {
         int len = PyTuple_Size(obj);
         double *data = (double *) malloc(sizeof(double) * len);
         if (data) {
            for (int j = 0; j < len; j++) {
               PyObject *item = PyTuple_GET_ITEM(obj, j);
               if (PyNumber_Check(item))
                  data[j] = PyFloat_AsDouble(item);
               else
                  data[j] = 0.0;
            }
            Array *array = (Array *) malloc(sizeof(Array));
            if (array) {
               array->data = data;
               array->len = len;
               rtcmixargs[i] = array;
            }
            else
               rtcmixargs[i] = 0.0;
         }
         else
            rtcmixargs[i] = 0.0;
      }
      else if (PyList_Check(obj)) {    // similar to tuples
         int len = PyList_Size(obj);
         double *data = (double *) malloc(sizeof(double) * len);
         if (data) {
            for (int j = 0; j < len; j++) {
               PyObject *item = PyList_GET_ITEM(obj, j);
               if (PyNumber_Check(item))
                  data[j] = PyFloat_AsDouble(item);
               else
                  data[j] = 0.0;
            }
            Array *array = (Array *) malloc(sizeof(Array));
            if (array) {
               array->data = data;
               array->len = len;
               rtcmixargs[i] = array;
            }
            else
               rtcmixargs[i] = 0.0;
         }
         else
            rtcmixargs[i] = 0.0;
      }
      else {
         char buf[128];
         sprintf(buf, "invalid argument type to '%s' (arg %d)", funcname, i);
         PyErr_SetString(PyExc_TypeError, buf);
         return NULL;
      }
   }

   Arg retval;
   int result = RTcmix::dispatch(funcname, rtcmixargs, nargs, &retval);

   delete [] rtcmixargs;

   PyObject *retobj = NULL;

   if (result == 0) {
      switch (retval.type()) {
         case DoubleType:
            retobj = PyFloat_FromDouble(retval);
            break;
         case StringType:
            retobj = PyString_FromString(retval);
            break;
         case HandleType:
            {
               OpaqueObject *newobj = newOpaqueObject(NULL);
               if (newobj == NULL) {
                  PyErr_SetString(PyExc_TypeError, "can't allocate new RtcHandle");
                  return NULL;
               }
               newobj->handle = (RtcHandle) retval;
               retobj = (PyObject *) newobj;
            }
            break;
         case ArrayType:
            break;
         default:
            break;
      }
   }

   return retobj;
}

