<html>
<head>
<title>The Sound Library</title>
<style type="text/css">
<!-- 
	EM.red {color:red; font-style:normal}
	EM.def {font-style:italic; font-weight: bold}
	H1 {text-align: center}
	UL {list-style-type: none}
	SPAN.box {background: beige; width: 100%; font-style: normal; text-align: center; border-width: thin; border-style: ridge}
	SPAN.bbox {background: lightsteelblue; width: 100%; font-style: normal; border-width: thin; border-style: ridge}
	SPAN.htmlbox {background: tan; font-style: normal; font-size: small; border-width: thin; border-style: ridge}
-->
</style>
</head>
<body bgcolor=white>
<h1>SndLib</h1>
<center>Bill Schottstaedt (bil@ccrma.stanford.edu)</center>
<br>
<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html">snd.html</a><spacer type=horizontal size=25><a href="extsnd.html">extsnd.html</a><spacer type=horizontal size=25><a href="grfsnd.html">grfsnd.html</a><spacer type=horizontal size=25><a href="clm.html">clm.html</a><spacer type=horizontal size=25><a href="sndscm.html">sndscm.html</a><spacer type=horizontal size=25><a href="index.html">index.html</a></span>
</center>
<br>
<span class=box><h2>Contents</h2></span>
<ul>
<li><a href="#introduction">Introduction</a>
<li><a href="#headers">Headers</a>
<li><a href="#data">Data</a>
<li><a href="#hardware">Hardware</a>
<li><a href="#music5">Music V</a>
<li><a href="#examples">Examples</a>
<ul>
<li><a href="#sndinfo">SndInfo</a>
<li><a href="#sndplay">SndPlay</a>
<li><a href="#sndrecord">SndRecord</a>
<li><a href="#audinfo">AudInfo</a>
<li><a href="#sndsine">SndSine</a>
<li><a href="#clmosc">clmosc</a>
<li><a href="#otherexamples">Other Examples</a>
</ul>
<li><a href="#building">How to Make Sndlib and the examples</a>
<li><a href="#currentstatus">Current Status</a>
<li><a href="#lowerlevels">Lower Levels</a>
<li><a href="#sndlibguile">Sndlib and Guile</a>
<li><a href="#sndlibcl">Sndlib and Common Lisp</a>
</ul>
<br>
<span class=box><h2><A NAME="introduction">Introduction</a></h2></span>

<p>The sound library is a collection of sound file and audio hardware
handlers written in C and running currently on SGI (either
audio library), NeXT, Sun, OSS or ALSA (Linux and others), Mac, Mac OS-X, HPUX, LinuxPPC, and Windoze systems.  
It provides relatively straightforward access to many sound file headers and data
types, and most of the features of the audio hardware. </p>

<p>The following files make up sndlib:</p>
<ul>
<li>io.c (read and write sound file data)
<li>headers.c (read and write sound file headers)
<li>audio.c (read and write sound hardware ports)
<li>sound.c (provide slightly higher level access to the preceding files)
<li>sndlib.h (header for the preceding files)
<li>sndlib2xen.c and sndlib-strings.h (tie preceding into Guile or Ruby)
<li>clm.c and clm.h (Music V implementation)
<li>clm2xen.c, vct.c and vct.h (tie clm.c into Guile or Ruby)
<li>xen.h, xen.c, xen.html (the embedded language support)
<li>old-sndlib.h (old names)
</ul>
<p>In version 6 and then to a greater extent in version 10, I changed the exported names to
use the prefix "mus" or "MUS"; see old-sndlib.h for backwards compatibility;
also, if you have common lisp, you can automatically translate files from 
version 9 or earlier to version 10 by loading transnd.cl and calling
the translate function.  The naming scheme is more as less as follows:
constants start with "MUS_", audio hardware constants with "MUS_AUDIO_",
functions involving sound files referenced through the file name
start with "mus_sound_", functions involving files at a lower level
with "mus_file_", functions involving header access with "mus_header_",
functions involving audio hardware access with "mus_audio_", and various
others just with "mus_" (number translations, etc).  Conversions use
the word "to" as in "mus_samples_to_bytes".
</p>
<p>To build sndlib (sndlib.so if possible, and sndlib.a):</p>
<pre>
  ./configure
  make
</pre>
<p>To install it, 'make install' -- I've tested this process in Linux,
SGI, Sun, and NeXT.  It could conceivably work elsewhere.  For more
details see <a href="#building">How to Make Sndlib</a> below.</p>

<br>
<span class=box><h2><A NAME="headers">Headers</a></h2></span>

<p>Sound files have built-in descriptors known as headers.
The following functions return the information in the header.
In each case the argument to the function is the full file
name of the sound file.
</p>
<pre>
  int mus_sound_samples (const char *arg)          /* samples of sound according to header (can be incorrect) */
  int mus_sound_frames (const char *arg)           /* samples per channel */
  float mus_sound_duration (const char *arg)
  int mus_sound_datum_size (const char *arg)       /* bytes per sample */
  int mus_sound_data_location (const char *arg)    /* location of first sample (bytes) */
  int mus_sound_chans (const char *arg)            /* number of channels (samples are interleaved) */
  int mus_sound_srate (const char *arg)            /* sampling rate */
  int mus_sound_header_type (const char *arg)      /* header type (aiff etc) */
  int mus_sound_data_format (const char *arg)      /* data format (alaw etc) */
  int mus_sound_original_format (const char *arg)  /* unmodified data format specifier */
  char *mus_sound_comment (const char *arg)        /* comment if any */
  int mus_sound_comment_start (const char *arg)    /* comment start (bytes) if any */
  int mus_sound_comment_end (const char *arg)      /* comment end (bytes) */
  int mus_sound_length (const char *arg)           /* true file length (for error checks) */
  int mus_sound_fact_samples (const char *arg)     /* compression scheme data */
  int mus_sound_distributed (const char *arg)      /* is header scattered around in sound file */
  int mus_sound_write_date (const char *arg)       /* bare (uninterpreted) file write date */
  int mus_sound_type_specifier (const char *arg)   /* original header type identifier */
  int mus_sound_align (const char *arg)            /* more compression data */
  int mus_sound_bits_per_sample(const char *arg)   /* bits per sample */
  int mus_data_format_to_bytes_per_sample(int format) /* bytes per sample */
  int mus_sound_max_amp(const char *arg, int *vals)/* return list of max-amp sample pairs */
  int mus_sound_aiff_p(const char *arg)            /* is it an old-style AIFF file (not AIFC) */
  int *mus_sound_loop_info(const char *arg)        /* 6 loop vals (mode,start,end) then base-detune and base-note  (empty list if no loop info found) */
  int mus_sound_initialize(void)                   /* initialize everything */
</pre>
<p>The following can be used to provide user-understandable descriptions
of the header type and the data format:</p>
<pre>
  char *mus_header_type_name(int type)      /* "AIFF" etc */
  char *mus_data_format_name(int format)    /* "16-bit big endian linear" etc */
</pre>
<p>In all cases if an error occurs, -1 is returned, and some sort of error message
is printed; to customize error handling, use mus_set_error_handler and mus_set_print_handler.</p>
<pre>
  mus_error_handler_t *mus_error_set_handler(mus_error_handler_t *new_error_handler);
  mus_print_handler_t *mus_print_set_handler(mus_print_handler_t *new_print_handler);
</pre>
<p>To decode the error indication, use:</p>
<pre>
  char *mus_error_to_string(int err);
</pre>

<p>Header data is cached internally, so the actual header is read
only if it hasn't already been read, or the write date has changed.
Loop points are also available, if there's interest.  To go below the
"sound" level, see headers.c -- once a header has been read, all the
components that have been found can be read via functions such as
<b>mus_header_srate</b>.
</p>

<br>
<span class=box><h2><A NAME="data">Data</a></h2></span>

<p>The following functions provide access to
sound file data:</p>
<pre>
  int mus_sound_open_input (const char *arg) 
  int mus_sound_open_output (const char *arg, int srate, int chans, int data_format, int header_type, const char *comment)
  int mus_sound_reopen_output (const char *arg, int type, int format, int data_loc)
  int mus_sound_close_input (int fd) 
  int mus_sound_close_output (int fd, int bytes_of_data) 
  int mus_sound_read (int fd, int beg, int end, int chans, MUS_SAMPLE_TYPE **bufs) 
  int mus_sound_write (int fd, int beg, int end, int chans, MUS_SAMPLE_TYPE **bufs) 
  int mus_sound_seek (int fd, long offset, int origin) 
  int mus_sound_seek_frame (int fd, int frame)
</pre>
<p>MUS_SAMPLE_TYPE defaults to int, but can also be float -- it is set when
sndlib is built and refers to Sndlib's internal representation of sample values.  
There are corresponding macros to convert from the
sample type to C types (MUS_SAMPLE_TO_FLOAT, etc), and the reverse
(MUS_FLOAT_TO_SAMPLE, etc).</p>

<p><i>mus_sound_open_input</i> opens <i>arg</i> for reading.  Most standard
uncompressed formats are readable.  This function returns the associated
file number, or -1 upon failure. </p>

<p><i>mus_sound_close_input</i> closes an open sound file.  Its argument is
the integer returned by mus_sound_open_input.</p>

<p><i>mus_sound_open_output</i> opens <i>arg</i>, setting its sampling rate
to be <i>srate</i>, number of channels to <i>chans</i>, data format
to <i>data_format</i> (see sndlib.h for these types: MUS_BSHORT,
for example, means 16-bit 2's complement big endian fractions),
header type to <i>header_type</i> (AIFF for example; the available
writable header types are MUS_AIFC (or AIFF), MUS_RIFF ('wave'),
MUS_NEXT, MUS_NIST, and MUS_IRCAM), and comment (if any) to
<i>comment</i>.  The header is not considered complete without
an indication of the data size, but since this is rarely known
in advance, it is supplied when the sound file is closed.  This
function returns the associated file number.</p>

<p><i>mus_sound_close_output</i> first updates the file's header to 
reflect the final data size <i>bytes_of_data</i>, then closes
the file.  The argument <i>fd</i> is the integer returned by
mus_sound_open_output.</p>

<p><i>mus_sound_read</i> reads data from the file indicated by <i>fd</i>,
placing data in the array <i>obufs</i> as 32-bit integers in the
host's byte order.  <i>chans</i> determines how many arrays of
ints are in obufs, which is filled by mus_sound_read from its
index <i>beg</i> to <i>end</i> with zero padding if necessary.
See the sndplay example below if this is not obvious.</p>

<p><i>mus_sound_write</i> writes data to the file indicated by <i>fd</i>,
starting for each of <i>chans</i> channels in <i>obufs</i> at
<i>beg</i> and ending at <i>end</i>.</p>

<p><i>mus_sound_seek</i> moves the read or write position for the
file indicated by <i>fd</i> to <i>offset</i> given the
<i>origin</i> indication (both treated as in lseek).
The new actual position attained is returned.  In both
cases (the returned value and offset), the output datum
size is considered to be 2, no matter what it really is.
That is, use byte positions as if you were always reading
and writing 16-bit data, and mus_sound_seek will compensate
if its actually 32-bit floats or whatever.  Since this
is impossible to understand, there's also mus_sound_seek_frame
which moves to the indicated frame.
</p>

<br>
<span class=box><h2><A NAME="hardware">Hardware</a></h2></span>

<p>The following functions provide access to audio harware.  If an
error occurs, they return -1. </p>
<pre>
  int mus_audio_initialize(void)
  void mus_audio_save(void)
  void mus_audio_restore(void)
  void mus_audio_describe(void)
  char *mus_audio_report(void)
  int mus_audio_open_output(int dev, int srate, int chans, int format, int size)
  int mus_audio_open_input(int dev, int srate, int chans, int format, int size)
  int mus_audio_write(int line, char *buf, int bytes)
  int mus_audio_close(int line)
  int mus_audio_read(int line, char *buf, int bytes)
  int mus_audio_mixer_read(int dev, int field, int chan, float *val)
  int mus_audio_mixer_write(int dev, int field, int chan, float *val)
  int mus_audio_systems(void)
  char *mus_audio_system_name(int system)
  void mus_audio_set_dsp_devices(int cards, int *dsps, int *mixers)
</pre>

<p><i>mus_audio_initialize</i> takes care of any necessary initialization.</p>

<p><i>mus_audio_save</i> saves the current audio hardware state.</p>

<p><i>mus_audio_restore</i> restores the audio hardware to the last saved state.</p>

<p><i>mus_audio_describe</i> prints to stdout a description of the
current state of the audio hardware.  <i>mus_audio_report</i>
returns the same description as a string.</p>

<p><i>mus_audio_systems</i> returns the number of separate and complete
audio systems (soundcards essentially) that are available.
<i>mus_audio_system_name</i>  returns some user-recognizable name for the given card.
</p>

<p><i>mus_audio_open_input</i> opens an audio port to read sound data (i.e. a microphone, line in, etc).
The input device is <i>dev</i> (see sndlib.h for details; when in doubt, use MUS_AUDIO_DEFAULT).
The input sampling rate is <i>srate</i> or as close as we
can get to it.  The number of input channels (if available) is <i>chans</i>.
The input data format is <i>format</i> (when in doubt, use the macro MUS_COMPATIBLE_FORMAT).
And the input buffer size (if settable at all) is <i>size</i> (bytes).  This
function returns an integer to distinguish its port from others that might be
in use.  In this and other related functions, the device has an optional second
portion that refers to the soundcard or system for that device.  MUS_AUDIO_PACK_SYSTEM(n)
refers to the nth such card, so (SNDLIB_DAC_DEVICE | MUS_AUDIO_PACK_SYSTEM(1)) is the 2nd
card's dac (the default is system 0, the first card).
</p>

<p><i>mus_audio_open_output</i> opens an audio port to write date (i.e. speakers, line out, etc).
The output device is <i>dev</i> (see sndlib.h).  Its sampling rate is <i>srate</i>, number
of channels <i>chans</i>, data format <i>format</i>, and buffer size <i>size</i>.  This
function returns the associated line number of the output port.</p>

<p><i>mus_audio_close</i> closes the port (input or output) associated with <i>line</i>.</p>

<p><i>mus_audio_read</i> reads sound data from <i>line</i>.  The incoming <i>bytes</i> bytes of data are placed
in <i>buf</i>.  If no error was returned from mus_audio_open_input, the data is in the format requested
by that function with channels interleaved.</p>

<p><i>mus_audio_write</i> writes <i>bytes</i> bytes of data in <i>buf</i> to the output
port associated with <i>line</i>.  This data is assumed to be in the format
requested by mus_audio_open_output with channels interleaved.</p>

<p><A NAME="readaudiostate"><i>mus_audio_mixer_read</i></a> and <i>mus_audio_mixer_write</i> are complicated.  They
get and set the audio hardware state.  The audio hardware is treated as a
set of "systems" (sound cards) each of which has a set of "devices" (dacs, adcs, etc),
with various "fields" that can be read or set (gain, channels active, etc).
For example, a microphone is called
the MUS_AUDIO_MICROPHONE, and its hardware gain setting (if any) is called
the MUS_AUDIO_AMP.  All gains are considered to be linear between 0.0 and
1.0, so to set the microphone's first channel amplitude to .5 (that is,
the gain of the signal before it reaches the analog-to-digital converter),</p>
<pre>
  float vals[1];
  vals[0]=0.5;
  mus_audio_mixer_write(MUS_AUDIO_MICROPHONE,MUS_AUDIO_AMP,0,vals);
</pre>
<p>Similarly</p>
<pre>
  mus_audio_mixer_read(MUS_AUDIO_MICROPHONE,MUS_AUDIO_AMP,0,vals);
  amp=vals[0];
</pre>
<p>returns the current gain in the float array vals.  mus_audio_mixer_read
can also return a description of the currently available audio
hardware.</p>

<p>If a requested operation is not implemented or something goes wrong, -1 is returned.</p>

<h4>Systems</h4>
<p>Each separate sound card is called a system, accessible via the <i>device</i>
argument through the macro MUS_AUDIO_PACK_SYSTEM(n). The count starts at 0 which is the default.  The
function <b>mus_audio_systems</b> returns how many such cards are available.  (Currently
it returns more than one only on Linux systems with multiple sound cards).
</p>

<h4>Devices</h4>
<p>Each audio system has a set of available devices.  To find out what is 
available on a given system</p>
<pre>
  #define LIST_MAX_SIZE 32;
  float device_list[LIST_MAX_SIZE];
  mus_audio_mixer_read(MUS_AUDIO_PACK_SYSTEM(0),MUS_AUDIO_PORT,LIST_MAX_SIZE,device_list);
</pre>
<p>The list of available devices is returned in the device_list array,
with the number of the devices as device_list[0].  The set of device
identifiers is in sndlib.h (MUS_AUDIO_LINE_IN for example). Two special
devices are MUS_AUDIO_MIXER and MUS_AUDIO_DAC_FILTER.  The latter refers
to the low-pass filter often associated with a DAC.  The former
refers to a set of analog gain and tone controls often associated
with a sound card.  The individual gains are accessed through the
various fields (described below).
</p>

<h4>Fields</h4>
<p>The field argument in mus-audio-mixer-read and mus-audio-mixer-write selects
one aspect of the given card's devices' controls.  
The simplest operations involve MUS_AUDIO_AMP and MUS_AUDIO_SRATE.  The latter
gets or sets the sampling rate of the device, and the former gets or sets
the amplitude (between 0.0 and 1.0) of the specified channel of the device.
The value to be set or returned is in the 0th element of the <i>vals</i>
array.  An example of reading the current microphone gain is given above.
The meaning of the field argument can depend on which device it is
applied to, so there is some complexity here.  The <i>channel</i>
argument usually selects which channel we are interested in, but in
some cases it instead tells mus-audio-mixer-read how big a returned list
can get.  A brief description of the fields:</p>
<pre>
MUS_AUDIO_AMP       gain or volume control (0.0 to 1.0)
MUS_AUDIO_SRATE     sampling rate
MUS_AUDIO_CHANNEL   active channels

MUS_AUDIO_BASS, MUS_AUDIO_TREBLE    mixer's tone control
MUS_AUDIO_LINE                      mixer's line-in gain control
MUS_AUDIO_MICROPHONE                mixer's microphone gain control
similarly for MUS_AUDIO_IMIX, MUS_AUDIO_IGAIN, 
              MUS_AUDIO_RECLEV, MUS_AUDIO_PCM, MUS_AUDIO_PCM2,
              MUS_AUDIO_OGAIN, MUS_AUDIO_LINE1, 
              MUS_AUDIO_LINE2, MUS_AUDIO_LINE3, MUS_AUDIO_SYNTH 

MUS_AUDIO_FORMAT    return list of usable sound formats (e.g. MUS_BSHORT)
MUS_AUDIO_PORT      return list of available devices (e.g. MUS_AUDIO_MICROPHONE)
</pre>

<br>
<span class=box><h2><A NAME="music5">MusicV</a></h2></span>

<p>clm.c and friends implement all the generators found in CLM, a common lisp
music V implementation, and clm2xen.c ties these into the lanaguages supported by the
xen package (currently Guile and Ruby).  The
primary clm documentation (which describes both the Scheme and Common Lisp implementations)
is clm.html found in clm-2.tar.gz alongside sndlib at ccrma-ftp.
The simplest way to try these out is to load them into Snd; see extsnd.html,
<a href="sndscm.html#exampdoc">examp.scm</a>, and <a href="sndscm.html#sndtestdoc">snd-test.scm</a> in snd-5.tar.gz for more details.
The C implementation is essentially the same as the two Lisp versions, but (as might be expected), works
at a lower level, expecting the caller to handle garbage collection and so forth.
The following briefly describes the C calls (see clm.h).
</p>

<p>clm.c implements a bunch of generators and sound IO handlers.  Each generator
has three associated functions, make-gen, gen, and gen_p; the first
creates the generator (if needed), the second gets the next sample from
the generator, and the last examines some pointer to determine if it is
that kind of generator.  In addition, there are a variety of "generic"
functions that generators respond to: mus_free, for example, frees a
generator, and mus_frequency returns its current frequency, if relevant.
All generators are pointers to mus_any structs.  Finally, CLM has two
special data types: frame and mixer.  A frame is an array that represents
a multi-channel sample (that is, in a stereo file, at time 0.0, there
are two samples, one for each channel).  A mixer is a array of arrays
that represents a set of input and output scalers, as if it were the
current state of a mixing console's volume controls.  A frame (a multi-channel
input) can be "mixed" into a new frame (a multi-channel output) by passing
it through a "mixer" (a matrix, the operation being a matrix multiply).
</p>

<ul>
<li>oscil -- generate a sine wave.
<ul>
<li>mus_any *mus_make_oscil (float freq, float phase)
<li>float mus_oscil (mus_any *o, float fm, float pm)
<li>int mus_oscil_p (mus_any *ptr)
</ul>
<pre>
  mus_any *osc;
  init_mus_module();
  osc = mus_make_oscil(440.0,0.0);
  if (oscil_p(osc)) fprintf(stderr,"%.3f, %.3f ",.1 * mus_oscil(osc,0.0,0.0),mus_frequency(osc));
  mus_free(osc);
</pre>
</ul>
<p>The other generators are:</p>
<ul>
<li>sum_of_cosines -- generate a pulse train made up of cosines
<li>delay -- a delay line with optional interpolation
<li>tap -- read delay line
<li>comb -- comb filter
<li>notch -- notch filter
<li>all_pass -- all pass filter
<li>table_lookup -- interpolating table lookup
<li>sawtooth_wave, triangle_wave, pulse_train, square_wave
<li>rand -- white noise (a step function)
<li>rand-interp -- interpolating noise
<li>asymmetric_fm -- a variety of FM
<li>one_zero, two_zero, one_pole, two_pole -- basic filters
<li>formant -- create a formant region (two poles, two zeros)
<li>sine_summation -- another way to create sine waves
<li>filter, fir_filter, iir_filter -- direct form filters of any order
<li>wave_train -- sequence of possibly overlapping waves
<li>buffer -- a way to handle block processing in the generator world
<li>env -- envelopes
<li>waveshape -- waveshaping
<li>readin, file2sample, file2frame, in_any -- file sample input
<li>locsig, sample2file, frame2file, out_any -- file sample output
<li>src -- sampling rate conversion
<li>granulate -- granular synthesis
<li>convolve -- convolution
<li>phase-vocoder -- phase vocoder
</ul>

<p>Some useful functions provided by clm.c are: </p>
<ul>
<li>float mus_radians2hz(float rads) -- convert radians/sample to cycles/sec.
<li>float mus_hz2radians(float hz) -- and the reverse.
<li>float mus_degrees2radians(float deg) -- convert degrees to radians.
<li>float mus_radians2degrees(float rads) -- and the reverse.
<li>float mus_srate(void) -- current sampling rate
<li>float mus_set_srate(float rate) -- set current sampling rate
<li>float mus_ring_modulate(float sig1, float sig2) -- multiply sig1 by sig2
<li>float mus_amplitude_modulate(float s1, float s2, float s3) -- AM
<li>float mus_contrast_enhancement(float sig, float index)
<li>float mus_dot_product(float *data1, float *data2, int size)
<li>void mus_clear_array(float *arr, int size)
<li>float mus_array_interp(float *wave, float phase, int size)
<li>float mus_polynomial(float *coeffs, float x, int ncoeffs);
<li>void mus_multiply_arrays(float *data, float *window, int len);
<li>void mus_rectangular2polar(float *rl, float *im, int size);
<li>void mus_spectrum(float *rdat, float *idat, float *window, int n, int type)
<li>void mus_fft(float *rl, float *im, int n, int isign)
<li>float *mus_make_fft_window(int size, int type, float beta)
<li>void mus_convolution(float* rl1, float* rl2, int n, int ipow)
<li>float *mus_partials2wave(float *partial_data, int partials, float *table, int table_size, int normalize)
<li>float *mus_phasepartials2wave(float *partial_data, int partials, float *table, int table_size, int normalize)
</ul>
<p>and various others -- see clm.h.</p>

<p>The more useful generic functions are:</p>
<ul>
<li>int mus_free(mus_any *ptr)
<li>char *mus_describe(mus_any *gen)
<li>float mus_phase(mus_any *gen)
<li>float mus_set_phase(mus_any *gen, float val)
<li>float mus_set_frequency(mus_any *gen, float val)
<li>float mus_frequency(mus_any *gen)
<li>float mus_run(mus_any *gen, float arg1, float arg2)
<li>int mus_length(mus_any *gen)
<li>int mus_set_length(mus_any *gen, int len)
<li>float *mus_data(mus_any *gen)
<li>float *mus_set_data(mus_any *gen, float *data)
<li>char *mus_name(mus_any *ptr)
<li>int mus_type(mus_any *ptr)
<li>float mus_scaler(mus_any *gen)
<li>float mus_set_scaler(mus_any *gen, float val)
<li>float mus_apply(mus_any *gen, ...)
</ul>

<p>Before using any of these functions, call init_mus_module.  Errors are reported
through mus_error which can be redirected or muffled.  See clm2xen.c for an example.
</p>
<br>

<span class=box><h2><A NAME="examples">Examples</a></h2></span>

<p>In the following examples I've omitted the usual garrulous C-header
gab and other inessential stuff.  The full
program code is available as noted below.</p>
<br>
<span class=bbox><h3><A NAME="sndinfo">SndInfo</a></h3></span>

<p>This program prints out a description of a sound file (sndinfo.c).</p>
<pre>
int main(int argc, char *argv[])
{
  int fd, chans, srate, samples;
  float length;
  time_t date;
  char *comment;
  char timestr[64];
  mus_sound_initialize();	
  fd = mus_file_open_read(argv[1]); /* see if it exists */
  if (fd != -1)
    {
      close(fd);
      date = mus_sound_write_date(argv[1]);
      srate = mus_sound_srate(argv[1]);
      chans = mus_sound_chans(argv[1]);
      samples = mus_sound_samples(argv[1]);
      comment = mus_sound_comment(argv[1]); 
      length = (float)samples / (float)(chans * srate);
      strftime(timestr, 64, "%a %d-%b-%y %H:%M %Z", localtime(&amp;date));
      fprintf(stdout, "%s:\n  srate: %d\n  chans: %d\n  length: %f\n", 
	      argv[1], srate, chans, length);
      fprintf(stdout, "  type: %s\n  format: %s\n  written: %s\n  comment: %s\n", 
	      mus_header_type_name(mus_sound_header_type(argv[1])), 
	      mus_data_format_name(mus_sound_data_format(argv[1])), 
	      timestr, comment);
    }
  else
    fprintf(stderr, "%s: %s\n", argv[1], strerror(errno));
  return(0);
}
</pre>
<br>
<span class=bbox><h3><A NAME="sndplay">SndPlay</a></h3></span>

<p>This code plays a sound file (sndplay.c):</p>

<pre>

int main(int argc, char *argv[])
{
  int fd, afd, i, j, n, k, chans, srate, frames, outbytes;
  MUS_SAMPLE_TYPE **bufs;
  short *obuf;
  mus_sound_initialize();	
  fd = mus_sound_open_input(argv[1]);
  if (fd != -1)
    {
      chans = mus_sound_chans(argv[1]);
      srate = mus_sound_srate(argv[1]);
      frames = mus_sound_frames(argv[1]);
      outbytes = BUFFER_SIZE * chans * 2;
      bufs = (MUS_SAMPLE_TYPE **)calloc(chans, sizeof(MUS_SAMPLE_TYPE *));
      for (i=0;i&lt;chans;i++) 
        bufs[i] = (MUS_SAMPLE_TYPE *)calloc(BUFFER_SIZE, sizeof(MUS_SAMPLE_TYPE));
      obuf = (short *)calloc(BUFFER_SIZE * chans, sizeof(short));
      afd = mus_audio_open_output(MUS_AUDIO_DEFAULT, srate, chans, MUS_COMPATIBLE_FORMAT, outbytes);
      if (afd != -1)
	{
	  for (i = 0; i &lt; frames; i += BUFFER_SIZE)
	    {
	      mus_sound_read(fd, 0, BUFFER_SIZE - 1, chans, bufs);
	      for (k = 0, j = 0; k &lt; BUFFER_SIZE; k++, j += chans)
		for (n = 0; n &lt; chans; n++) 
                  obuf[j + n] = MUS_SAMPLE_TO_SHORT(bufs[n][k]);
	      mus_audio_write(afd, (char *)obuf, outbytes);
	    }
	  mus_audio_close(afd);
	}
      mus_sound_close_input(fd);
      for (i = 0; i &lt; chans; i++) free(bufs[i]);
      free(bufs);
      free(obuf);
    }
  return(0);
}

</pre>
<br>
<span class=bbox><h3><A NAME="sndrecord">SndRecord</a></h3></span>

<p>This code records a couple seconds of sound from a microphone.
Input formats and sampling rates are dependent on available
hardware, so in a "real" program, you'd use <a href="#readaudiostate">mus_audio_mixer_read</a>
to find out what was available, then mus_file_read_buffer to
turn that data into a stream of floats.
You'd also provide, no doubt,
some whizzy user interface to turn the thing off. (sndrecord.c)</p>
<pre>
int main(int argc, char *argv[])
{
  int fd, afd, i, err;
  short *ibuf;
#if MACOS
  argc = ccommand(&amp;argv);
#endif
  afd = -1;
  mus_sound_initialize();	
  fd = mus_sound_open_output(argv[1], 22050, 1, MUS_BSHORT, MUS_NEXT, "created by sndrecord");
  if (fd != -1)
    {
      ibuf = (short *)calloc(BUFFER_SIZE, sizeof(short));
      afd = mus_audio_open_input(MUS_AUDIO_MICROPHONE, 22050, 1, MUS_BSHORT, BUFFER_SIZE);
      if (afd != -1)
	{
	  for (i = 0; i &lt; 10; i++) /* grab 10 buffers of input */
	    {
	      err = mus_audio_read(afd, (char *)ibuf, BUFFER_SIZE * 2);
	      if (err != MUS_NO_ERROR) break;
	      write(fd, ibuf, BUFFER_SIZE * 2);
	    }
	  mus_audio_close(afd);
	}
      mus_sound_close_output(fd, BUFFER_SIZE * 10 * 2);
      free(ibuf);
    }
  return(0);
}
</pre>

<br>
<span class=bbox><h3><A NAME="audinfo">AudInfo</a></h3></span>

<p>This program describes the current audio harware state (audinfo.c):</p>
<pre>

int main(int argc, char *argv[])
{
  mus_sound_initialize();	
  mus_audio_describe();
  return(0);
}
</pre>

<br>
<span class=bbox><h3><A NAME="sndsine">SndSine</a></h3></span>

<p>This program writes a one channel NeXT/Sun sound file
containing a sine wave at 440 Hz.</p>

<pre>
int main(int argc, char *argv[])
{
  int fd, i, k, frames;
  float phase, incr;
  MUS_SAMPLE_TYPE *obuf[1];
  mus_sound_initialize();	
  fd = mus_sound_open_output(argv[1], 22050, 1, MUS_BSHORT, MUS_NEXT, "created by sndsine");
  if (fd != -1)
    {
      frames = 22050;
      phase = 0.0;
      incr = 2 * M_PI * 440.0 / 22050.0;
      obuf[0] = (MUS_SAMPLE_TYPE *)calloc(BUFFER_SIZE, sizeof(MUS_SAMPLE_TYPE));
      k = 0;
      for (i = 0; i &lt; frames; i++)
	{
	  obuf[0][k] = MUS_FLOAT_TO_SAMPLE(0.1 * sin(phase)); /* amp = .1 */
	  phase += incr;
	  k++;
	  if (k == BUFFER_SIZE)
	    {
	      mus_sound_write(fd, 0, BUFFER_SIZE-1, 1, obuf);
	      k=0;
	    }
	}
      if (k &gt; 0) mus_sound_write(fd, 0, k - 1, 1, obuf);
      mus_sound_close_output(fd, 22050 * mus_data_format_to_bytes_per_sample(MUS_BSHORT));
      free(obuf[0]);
    }
  return(0);
}
</pre>

<br>
<span class=bbox><h3><A NAME="clmosc">clmosc</a></h3></span>

<p>This is program uses the clm.c oscillator and output functions to write the same sine wave 
as we wrote in SndSine.<p>
<pre>
int main(int argc, char *argv[])
{
  int i;
  mus_any *osc, *op;
  mus_sound_initialize();	
  init_mus_module();
  osc = mus_make_oscil(440.0, 0.0);
  op = mus_make_sample2file("test.snd", 1, MUS_BSHORT, MUS_NEXT);
  if (op) 
    for (i = 0; i &lt; 22050; i++) 
      mus_sample2file(op, i, 0, .1 * mus_oscil(osc, 0.0, 0.0));
  mus_free(osc);
  if (op) mus_free(op);
  return(0);
}
</pre>
<p>Here is the fm-violin and a sample with-sound call:</p>
<pre>
static int feq(float x, int i) {return(fabs(x-i)&lt;.00001);}

void fm_violin(float start, float dur, float frequency, float amplitude, float fm_index, mus_any *op)
{
 float pervibfrq = 5.0,
   ranvibfrq = 16.0,
   pervibamp = .0025,
   ranvibamp = .005,
   noise_amount = 0.0,
   noise_frq = 1000.0,
   gliss_amp = 0.0,
   fm1_rat = 1.0,
   fm2_rat = 3.0,
   fm3_rat = 4.0,
   reverb_amount = 0.0,
   degree = 0.0, 
   distance = 1.0;
  float fm_env[] = {0.0, 1.0, 25.0, 0.4, 75.0, 0.6, 100.0, 0.0};
  float amp_env[] = {0.0, 0.0,  25.0, 1.0, 75.0, 1.0, 100.0, 0.0};
  float frq_env[] = {0.0, -1.0, 15.0, 1.0, 25.0, 0.0, 100.0, 0.0};
  int beg = 0, end, easy_case = 0, npartials, i;
  float *coeffs, *partials;
  float frq_scl, maxdev, logfrq, sqrtfrq, index1, index2, index3, norm;
  float vib = 0.0, modulation = 0.0, fuzz = 0.0, indfuzz = 1.0, ampfuzz = 1.0;
  mus_any *carrier, *fmosc1, *fmosc2, *fmosc3, *ampf;
  mus_any *indf1, *indf2, *indf3, *fmnoi = NULL, *pervib, *ranvib, *frqf = NULL, *loc;
  beg = start * mus_srate();
  end = beg + dur * mus_srate();
  frq_scl = mus_hz2radians(frequency);
  maxdev = frq_scl * fm_index;
  if ((noise_amount == 0.0) &amp;&amp; 
      (feq(fm1_rat, floor(fm1_rat))) &amp;&amp; 
      (feq(fm2_rat, floor(fm2_rat))) &amp;&amp; 
      (feq(fm3_rat, floor(fm3_rat)))) 
    easy_case = 1;
  logfrq = log(frequency);
  sqrtfrq = sqrt(frequency);
  index1 = maxdev * 5.0 / logfrq; 
  if (index1 &gt; M_PI) index1 = M_PI;
  index2 = maxdev * 3.0 * (8.5 - logfrq) / (3.0 + frequency * .001); 
  if (index2 &gt; M_PI) index2 = M_PI;
  index3 = maxdev * 4.0 / sqrtfrq; 
  if (index3 &gt; M_PI) index3 = M_PI;
  if (easy_case)
    {
      npartials = floor(fm1_rat);
      if ((floor(fm2_rat)) &gt; npartials) npartials = floor(fm2_rat);
      if ((floor(fm3_rat)) &gt; npartials) npartials = floor(fm3_rat);
      npartials++;
      partials = (float *)CALLOC(npartials, sizeof(float));
      partials[(int)(fm1_rat)] = index1;
      partials[(int)(fm2_rat)] = index2;
      partials[(int)(fm3_rat)] = index3;
      coeffs = mus_partials2polynomial(npartials, partials, 1);
      norm = 1.0;
    }
  else norm = index1;
  carrier = mus_make_oscil(frequency, 0.0);
  if (easy_case == 0)
    {
      fmosc1 = mus_make_oscil(frequency * fm1_rat, 0.0);
      fmosc2 = mus_make_oscil(frequency * fm2_rat, 0.0);
      fmosc3 = mus_make_oscil(frequency * fm3_rat, 0.0);
    }
  else fmosc1 = mus_make_oscil(frequency, 0.0);
  ampf = mus_make_env(amp_env, 4, amplitude, 0.0, 1.0, dur, 0, 0, NULL);
  indf1 = mus_make_env(fm_env, 4, norm, 0.0, 1.0, dur, 0, 0, NULL);
  if (gliss_amp != 0.0) 
    frqf = mus_make_env(frq_env, 4, gliss_amp * frq_scl, 0.0, 1.0, dur, 0, 0, NULL);
  if (easy_case == 0)
    {
      indf2 = mus_make_env(fm_env, 4, index2, 0.0, 1.0, dur, 0, 0, NULL);
      indf3 = mus_make_env(fm_env, 4, index3, 0.0, 1.0, dur, 0, 0, NULL);
    }
  pervib = mus_make_triangle_wave(pervibfrq, frq_scl * pervibamp, 0.0);
  ranvib = mus_make_rand_interp(ranvibfrq, frq_scl * ranvibamp);
  if (noise_amount != 0.0) fmnoi = mus_make_rand(noise_frq, noise_amount * M_PI);
  loc = mus_make_locsig(degree, distance, reverb_amount, 1, (mus_output *)op, NULL);
  for (i = beg; i &lt; end; i++)
    {
      if (noise_amount != 0.0) fuzz = mus_rand(fmnoi, 0.0);
      if (frqf) vib = mus_env(frqf); else vib = 0.0;
      vib += mus_triangle_wave(pervib, 0.0) + mus_rand_interp(ranvib, 0.0);
      if (easy_case)
	modulation = mus_env(indf1) * 
                     mus_polynomial(coeffs, mus_oscil(fmosc1, vib, 0.0), npartials);
      else
	modulation = mus_env(indf1) * mus_oscil(fmosc1, (fuzz + fm1_rat * vib), 0.0) + 
	             mus_env(indf2) * mus_oscil(fmosc2, (fuzz + fm2_rat * vib), 0.0) + 
	             mus_env(indf3) * mus_oscil(fmosc3, (fuzz + fm3_rat * vib), 0.0);
      mus_locsig(loc, i, mus_env(ampf) * mus_oscil(carrier, vib + indfuzz * modulation, 0.0));
    }
  mus_free(pervib);
  mus_free(ranvib);
  mus_free(carrier);
  mus_free(fmosc1);
  mus_free(ampf);
  mus_free(indf1);
  if (fmnoi) mus_free(fmnoi);
  if (frqf) mus_free(frqf);
  if (!(easy_case))
    {
      mus_free(indf2);
      mus_free(indf3);
      mus_free(fmosc2);
      mus_free(fmosc3);
    }
  else
    FREE(partials);
  mus_free(loc);
}

int main(int argc, char *argv[])
{
  mus_any *osc = NULL, *op = NULL;
  mus_sound_initialize();	
  init_mus_module();
  op = mus_make_sample2file("test.snd", 1, MUS_BSHORT, MUS_NEXT);
  if (op)
    {
      fm_violin(0.0, 20.0, 440.0, .3, 1.0, op);
      mus_free(op);
    }
  return(0);
}
</pre>
<p>The CLM version is v.ins, the Scheme version can be found in <a href="sndscm.html#exampdoc">examp.scm</a>.
This code can be run:</p>
<pre>
cc v.c -o vc -O3 -lm io.o headers.o audio.o sound.o clm.o -DLINUX
</pre>

<p>For generators such as src that take a function for "as-needed" input,
you can use something like:</p>
<pre>
static Float input_as_needed(void *arg, int dir) {/* get input here -- arg is "sf" passed below */}

static SCM call_phase-vocoder(void)
{
  mus_any *pv;
  int sf; /* file channel or whatever */
  pv = mus_make_phase_vocoder(NULL, 512, 4, 128, 0.5, NULL, NULL, NULL, (void *)sf);
  mus_phase_vocoder(pv, &amp;input_as_needed);
  /* etc */
}
</pre>
<br>
<span class=bbox><h3><A NAME="otherexamples">Other Examples</a></h3></span>

<p>The primary impetus for the sound library was the development
of Snd and CLM, both of which are freely available.</p>
<br>


<span class=bbox><h3><A NAME="building">How to Make Sndlib and the examples</a></h3></span>

<p>The Sndlib files can be used as separate modules or made into a
library.  The following sequence, for example, builds the sndplay
program from scratch on an SGI:</p>
<pre>
cc -c io.c -O -DSGI
cc -c headers.c -O -DSGI
cc -c audio.c -O -DSGI
cc -c sound.c -O -DSGI
cc sndplay.c -o sndplay -O -DSGI audio.o io.o headers.o sound.o -laudio -lm
</pre>
<p>To make a library out of 
the sndlib files, first compile them as above, then:</p>
<pre>
ld -r audio.o io.o headers.o sound.o -o sndlib.a
cc sndplay.c -o sndplay -O -DSGI sndlib.a -laudio -lm
</pre>
<p>The full sequence in Linux:</p>
<pre>
cc -c io.c -O -DLINUX
cc -c audio.c -O -DLINUX
cc -c headers.c -O -DLINUX
cc -c sound.c -O -DLINUX
cc sndplay.c -o sndplay -O -DLINUX audio.o io.o headers.o sound.o -lm

ld -r audio.o io.o headers.o sound.o -o sndlib.a
cc sndplay.c -o sndplay -O -DLINUX sndlib.a -lm
</pre>
<p>And on a NeXT:</p>
<pre>
cc -c io.c -O -DNEXT
cc -c audio.c -O -DNEXT
cc -c headers.c -O -DNEXT
cc -c sound.c -O -DNEXT
cc sndplay.c -o sndplay -O -DNEXT audio.o io.o headers.o sound.o 

ld -r audio.o io.o headers.o sound.o -o sndlib.a
cc sndplay.c -o sndplay -O -DNEXT sndlib.a
</pre>
<p>Some similar sequence should work on a Sun (-DSOLARIS) or in HP-UX (-DHPUX).
In Windoze, you can use the C IDE (a project builder),
or run the compiler from a DOS shell.  In the latter case,
(in Watcom C) cl io.c -c -DWINDOZE to create the object files (io.obj and so on), then</p>
<pre>
cl sndplay sndplay.obj -DWINDOZE audio.obj io.obj headers.obj sound.obj 
</pre>
<p>or in MS C</p>
<pre>
cl -c io.c -DWINDOZE
(and so on)
cl sndplay.c -DWINDOZE sndplay.obj audio.obj io.obj headers.obj sound.obj winmm.lib
</pre>
<p>or in gcc (available via the cygwin project)</p>
<pre>
gcc -c io.c -DWINDOZE -O2
</pre>
<p>
You can run the program from the DOS shell (sndplay oboe.snd or ./sndplay.exe oboe.snd).
Or</p>
<pre>
make sndplay
</pre>
<p>To make sndlib into a shared library,</p>
<pre>
ld -shared io.o headers.o audio.o sound.o -o sndlib.so
</pre>
<p>(in Linux), or (to include the CLM module),</p>
<pre>
ld -shared io.o headers.o audio.o sound.o clm.o -o sndlib.so
</pre>
<br>

<span class=box><h2><A NAME="currentstatus">Current Status</a></h2></span>
<br>
<center>
<table border=8 bordercolor="lightgreen"> 
  <tr><th>System<th>SndSine<th>SndInfo<th>Audinfo<th>SndPlay<th>SndRecord<th>CLM
  <tr><td width=180>NeXT 68k<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok
  <tr><td>NeXT Intel<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>interruptions<td align=middle>runs (*)<td align=middle>ok
  <tr><td>SGI old and new AL<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok
  <tr><td>OSS (Linux et al)<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok
  <tr><td>Mac<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok
  <tr><td>Windoze<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>not written<td align=middle>ok
  <tr><td>Sun<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>interruptions<td align=middle>ok
  <tr><td>HPUX<td align=middle>untested<td align=middle>untested<td align=middle>untested<td align=middle>untested<td align=middle>untested<td align=middle>untried
  <tr><td>LinuxPPC<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>untested (**)<td align=middle>ok
  <tr><td>ALSA<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok<td align=middle>ok
  <tr><td>Mac OS-X<td align=middle>ok<td align=middle>ok<td align=middle>not written<td align=middle>not written<td align=middle>not written<td align=middle>ok
</table>

<br>
<pre>
<small>
(*) I can't find a microphone.
(**) Last I looked, recording was still not supported in this OS.
</small>
</pre>
<br>
</center>

<ul>
<li>headers supported read/write
<ul>
<li>NeXT/Sun/DEC/AFsp
<li>AIFF/AIFC
<li>RIFF (Microsoft wave)
<li>IRCAM (old style)
<li>NIST-sphere
<li>no header
</ul>
<li>headers supported read-only
<ul>
<li>8SVX (IFF), EBICSF, INRS, ESPS, 
<li>SPPACK, ADC (OGI), AVR, VOC, PVF,
<li>Sound Tools, Turtle Beach SMP, SoundFont 2.0, 
<li>Sound Designer I and II, PSION, MAUD, Kurzweil 2000,
<li>Tandy DeskMate, Gravis Ultrasound, ASF, PAF, CSL,
<li>Comdisco SPW, Goldwave sample, omf, quicktime
<li>Sonic Foundry, SBStudio II, Delusion digital, 
<li>Digiplayer ST3, Farandole Composer WaveSample,
<li>Ultratracker WaveSample, Sample Dump exchange, 
<li>Yamaha SY85, SY99, and TX16, Covox v8, SPL, AVI
</ul>
</ul>

<pre>
<small>
Incomplete: OMF, AVI, ASF, QuickTime, SoundFont 2.0.
Not handled: Esignal, ILS, HTK, DVSM, SoundEdit.
Handled by Snd: Mus10, IEEE text, HCOM, various compression schemes.
</small>
</pre>
<br>
<span class=box><h2><A NAME="lowerlevels">Lower Levels</a></h2></span>

<p>If you'd like to go below the "sound" interface described above,
the following functions are exported from sndlib.  You need to remember
to call mus_sound_initialize (or the underlying initializers) before
using these functions (this is normally done for you by the various
"sound_" functions).</p>
<pre>
  int mus_header_read (char *name)
  int mus_header_write (char *name, int type, int in_srate, int in_chans, int loc, int size, int format, char *comment, int len)
  int mus_header_update (char *name, int type, int size, int srate, int format, int chans, int loc)
  int mus_header_writable(int type, int format)
</pre>

<p>These read and write a sound file's header.  The <i>loc</i> parameter is normally 0 (the data location depends
on many things -- you'd normally write the header, then use mus_header_data_location to get the resultant
data location). <i>len</i> is the length (bytes) of <i>comment</i>.  <i>mus_header_update</i> is normally
used only to set the file size after the sound has been written.  <i>mus_header_writable</i> returns
1 if the given combination of header type and data format can be handled by sndlib.  If you already have
the file descriptor (as returned by open), the corresponding lower level calls are:</p>
<pre>
  int mus_header_read_with_fd (int fd)
  int mus_header_write_with_fd (int fd, int type, int in_srate, int in_chans, int loc, int size, int format, char *comment, int len)
  int mus_header_update_with_fd (int fd, int type, int siz)
</pre>

<p>Once mus_header_read has been called, the data in it can be accessed through:</p>
<pre>
  int mus_header_samples (void)              samples 
  int mus_header_frames (void)               frames (samples / chans)
  int mus_header_data_location (void)        location of data (bytes)
  int mus_header_chans (void)                channels
  int mus_header_srate (void)                srate
  int mus_header_type (void)                 header type (i.e. aiff, wave, etc)  (see sndlib.h)
  int mus_header_format (void)               data format (see sndlib.h)
  int mus_header_distributed (void)          true if header info is scattered around in the file
  int mus_header_comment_start (void)        comment start location (if any) (bytes)
  int mus_header_comment_end (void)          comment end location
  int mus_header_aux_comment_start (int n)   if multiple comments, nth start location
  int mus_header_aux_comment_end (int n)     if multiple comments, nth end location
  int mus_header_type_specifier (void)       original (header-specific) type ID
  int mus_header_bits_per_sample (void)      sample width in bits
  int mus_header_true_length (void)          true (lseek) file length
  char *mus_header_type_name (int type)      header_type name
  char *mus_data_format_name (int format)    data_format name
</pre>

<p>Various less useful header fields are accessible:
see headers.c or sndlib.h for details.  The next functions handle various IO calls:</p>
<pre>
  int mus_file_open_read (const char *arg)              open file read-only
  int mus_file_probe (const char *arg)                  return 1 if file exists
  int mus_file_open_write (const char *arg)             open file read-write, creating it if necessary, else truncating
  int mus_file_create (const char *arg)                 create file
  int mus_file_reopen_write (const char *arg)           open file read-write without changing anything
  int mus_file_close (int fd)                           close file
  long mus_file_seek (int tfd, long offset, int origin) 
  int mus_file_seek_frame (int tfd, int frame)          go to a specific frame in file
  int mus_file_read (int fd, int beg, int end, int chans, MUS_SAMPLE_TYPE **bufs)
  int mus_file_read_chans (int fd, int beg, int end, int chans, MUS_SAMPLE_TYPE **bufs, MUS_SAMPLE_TYPE *cm)
  int mus_file_read_any (int tfd, int beg, int chans, int nints, MUS_SAMPLE_TYPE **bufs, MUS_SAMPLE_TYPE *cm)
  int mus_file_write_zeros (int tfd, int num)
  int mus_file_write (int tfd, int beg, int end, int chans, MUS_SAMPLE_TYPE **bufs)
  int mus_sound_max_amp (char *ifile, MUS_SAMPLE_TYPE *vals)
  int mus_sound_max_amp_exists (char *ifile)
  float mus_file_prescaler(int tfd)
  float mus_file_set_prescaler(int tfd, float val)
</pre>
<p>The prescaler functions are useful in several pathological cases.
If you're reading float data that is extremely soft (i.e. max amp
below .001), the transfer to integer form in sndlib can cause bits
to be lost, resulting in hiss.  In this case set the prescaler for
the file to 1000.0 or so to get the data into a more "normal"
range.  The mus_file_set_prescaler call should come just after opening
the sound file, before trying to read any data.
</p>

<p>If you're trying to deal with various data types yourself,
the following functions may be useful; they perform various
byte-order-aware type conversions:</p>
<pre>
  void mus_bint_to_char (unsigned char *j, int x)
  int mus_char_to_bint (const unsigned char *inp)
  void mus_lint_to_char (unsigned char *j, int x)
  int mus_char_to_lint (const unsigned char *inp)
  int mus_char_to_uninterpreted_int (unsigned char *inp)
  void mus_bfloat_to_char (const unsigned char *j, float x)
  float mus_char_to_bfloat (const unsigned char *inp)
  void mus_lfloat_to_char (unsigned char *j, float x)
  float mus_char_to_lfloat (const unsigned char *inp)
  void mus_bshort_to_char (unsigned char *j, short x)
  short mus_char_to_bshort (const unsigned char *inp)
  void mus_lshort_to_char (unsigned char *j, short x)
  short mus_char_to_lshort (const unsigned char *inp)
  void mus_ubshort_to_char (unsigned char *j, unsigned short x)
  unsigned short mus_char_to_ubshort (const unsigned char *inp)
  void mus_ulshort_to_char (unsigned char *j, unsigned short x)
  unsigned short mus_char_to_ulshort (unsigned char *inp)
  double mus_char_to_ldouble (const unsigned char *inp)
  double mus_char_to_bdouble (const unsigned char *inp)
  void mus_bdouble_to_char (unsigned char *j, double x)
  void mus_ldouble_to_char (unsigned char *j, double x)
  unsigned int mus_char_to_ubint (const unsigned char *inp)
  unsigned int mus_char_to_ulint (const unsigned char *inp)
</pre>

<p>Finally, a couple functions are provided to read and write sound files
to and from arrays:</p>
<pre>
  int mus_file_to_array (const char *filename, int chan, int start, int samples, MUS_SAMPLE_TYPE *array)
  int mus_array_to_file (const char *filename, MUS_SAMPLE_TYPE *ddata, int len, int srate, int channels)
</pre>
<br>
<span class=box><h2><A NAME="sndlibguile">Sndlib and Guile</a></h2></span>

<p>Much of sndlib is accessible at run time in any program that has one of
the languages supported by the xen package (Guile, Ruby);
the modules sndlib2xen and clm2xen tie most of the library into that language
making it possible to call the library functions from its interpreter.  The documentation
is scattered around, unfortunately: the clm side is in clm.html and extsnd.html with many
examples in Snd's <a href="sndscm.html#exampdoc">examp.scm</a>.  Most of these are obvious translations of the
constants and functions described above into Scheme. 
</p>
<pre>
  mus-next mus-aifc mus-riff mus-nist mus-raw mus-ircam mus-aiff

  mus-bshort mus-lshort mus-mulaw mus-alaw mus-byte mus-ubyte mus-bfloat
  mus-lfloat mus-bint mus-lint mus-b24int mus-l24int mus-bdouble mus-ldouble
  mus-ubshort mus-ulshort

  mus-audio-default mus-audio-duplex-default mus-audio-line-out mus-audio-line-in
  mus-audio-microphone mus-audio-speakers mus-audio-dac-out mus-audio-adat-in
  mus-audio-aes-in mus-audio-digital-in mus-audio-digital-out mus-audio-adat-out
  mus-audio-aes-out mus-audio-dac-filter mus-audio-mixer mus-audio-line1
  mus-audio-line2 mus-audio-line3 mus-audio-aux-input mus-audio-cd mus-audio-aux-output
  mus-audio-spdif-in mus-audio-spdif-out

  mus-audio-amp mus-audio-srate mus-audio-channel mus-audio-format mus-audio-port
  mus-audio-imix mus-audio-igain mus-audio-reclev mus-audio-pcm mus-audio-pcm2
  mus-audio-ogain mus-audio-line mus-audio-synth mus-audio-bass mus-audio-treble
  mus-audio-direction mus-audio-samples-per-channel

  mus-sound-samples (filename)             samples of sound according to header (can be incorrect)
  mus-sound-frames (filename)              frames of sound according to header (can be incorrect)
  mus-sound-duration (filename)            duration of sound in seconds
  mus-sound-datum-size (filename)          bytes per sample
  mus-sound-data-location (filename)       location of first sample (bytes)
  mus-sound-chans (filename)               number of channels (samples are interleaved)
  mus-sound-srate (filename)               sampling rate
  mus-sound-header-type (filename)         header type (e.g. <i>mus-aiff</i>)
  mus-sound-data-format (filename)         data format (e.g. <i>mus-bshort</i>)
  mus-sound-length (filename)              true file length (bytes)
  mus-sound-type-specifier (filename)      original header type identifier
  mus-sound-max-amp(filename)              returns a list of max amps and locations thereof
  mus-sound-loop-info(filename)            returns list of 4 loop values (the actual mark positions here, not
                                           the so-called id's), then base-note and base-detune
  
  mus-header-type-name (type)              e.g. "AIFF"
  mus-data-format-name (format)            e.g. "16-bit big endian linear"
  mus-sound-comment (filename)             header comment, if any
  mus-sound-write-date (filename)          sound write date
  data-format-bytes-per-sample (format)    bytes per sample

  mus-audio-describe ()                    describe audio hardware state
  mus-audio-report ()                      return audio hardware state as a string
  mus-audio-set-oss-buffers (num size)     in Linux (OSS) sets the number and size of the OSS "fragments"
  mus-audio-sun-outputs (speaker headphones line-out) On the Sun, cause output to go to the chosen devices

  mus-sound-open-input (filename)          open filename (a sound file) returning an integer ("fd" below)
  mus-sound-open-output (filename srate chans data-format header-type comment)
                                           create a new sound file with the indicated attributes, return "fd"
  mus-sound-reopen-output (filename chans data-format header-type data-location)
                                           reopen (without disturbing) filename, ready to be written
  mus-sound-close-input (fd)               close sound file
  mus-sound-close-output (fd bytes)        close sound file and update its length indication, if any
  mus-sound-read (fd beg end chans sdata)  read data from sound file <i>fd</i> loading the data array from beg to end
                                           <i>sdata</i> is a sound-data object that should be able to accommodate the read
  mus-sound-write (fd beg end chans sdata) write data to sound file <i>fd</i>
  mus-sound-seek (fd offset origin)        complicated -- see mus_sound_seek above
  mus-sound-seek-frame (fd frame)          move to <i>frame</i> in sound file <i>fd</i>
  mus-file-set-data-clipped (fd clipped)   set whether output is clipped

  mus-audio-open-output (device srate chans format bufsize)
                                           open audio port <i>device</i> ready for output with the indicated attributes
  mus-audio-open-input (device srate chans format bufsize)
                                           open audio port <i>device</i> ready for input with the indicated attributes
  mus-audio-write (line sdata frames)      write <i>frames</i> of data from sound-data object <i>sdata</i> to port <i>line</i>
  mus-audio-read (line sdata frames)       read <i>frames</i> of data into sound-data object <i>sdata</i> from port <i>line</i>
  mus-audio-close (line)                   close audio port <i>line</i>
  mus-audio-mixer-read (device field channel vals)
                                           read current state of <i>device</i>'s <i>field</i> -- see mus_audio_mixer_read above.
  mus-audio-mixer-write (device field channel vals)
                                           write new state for <i>device</i>'s <i>field</i> -- see mus_audio_mixer_write above.
  mus-audio-systems ()                     returns how many separate "systems" (soundcards) it can find.  To specify
                                           a particular system in the "device" parameters, add (ash system 16) to the device.
  mus-audio-save ()                        write current audio state to .mixer or whatever
  mus-audio-restore ()                     read previously stored audio state

  make-sound-data (chans, frames)      return a sound-data object with <i>chans</i> arrays, each of length <i>frames</i>
  sound-data-ref (obj chan frame)      return (as a float) the sample in channel <i>chan</i> at location <i>frame</i>
  sound-data-set! (obj chan frame val) set <i>obj</i>'s sample at <i>frame</i> in <i>chan</i> to (the float) <i>val</i>
  sound-data? (obj)                    #t if <i>obj</i> is of type sound-data
  sound-data-length (obj)              length of each channel of data in <i>obj</i>
  sound-data-chans (obj)               number of channels of data in <i>obj</i>
  sound-data-&gt;vct (sdobj chan vobj)    place sound-data channel data in vct 
  vct-&gt;sound-data (vobj sdobj chan)    place vct data in sound-data

;;; this function prints header information
(define info
  (lambda (file)
    (string-append
     file
     ": chans: " (number-&gt;string (mus-sound-chans file))
     ", srate: " (number-&gt;string (mus-sound-srate file))
     ", " (mus-header-type-name (mus-sound-header-type file))
     ", " (mus-data-format-name (mus-sound-data-format file))
     ", len: " (number-&gt;string
                (/ (mus-sound-samples file)
                   (* (mus-sound-chans file) (mus-sound-srate file)))))))

;;; this function reads the first 32 samples of a file, returning the 30th in channel 0
(define read-sample-30 
  (lambda (file)
    (let* ((fd (mus-sound-open-input file))
	   (chans (mus-sound-chans file))
	   (data (make-sound-data chans 32)))
      (mus-sound-read fd 0 31 chans data)
      ;; we could use sound-data-&gt;vct here to return all the samples
      (let ((val (sound-data-ref data 0 29)))
	(mus-sound-close-input fd)
	val))))

;;; here we get the microphone volume, then set it to .5
  (define vals (make-vector 32))
  (mus-audio-mixer-read mus-audio-microphone mus-audio-amp 0 vals)
  (vector-ref vals 0)
  (vector-set! vals 0 .5)
  (mus-audio-mixer-write mus-audio-microphone mus-audio-amp 0 vals)

;;; this function plays a sound (we're assuming that we can play 16-bit linear little-endian data)
(define play-sound
  (lambda (file)
    (let* ((sound-fd (mus-sound-open-input file))
	   (chans (mus-sound-chans file))
	   (frames (mus-sound-frames file))
	   (bufsize 256)
	   (data (make-sound-data chans bufsize))
	   (bytes (* bufsize chans 2)))
      (mus-sound-read sound-fd 0 (1- bufsize) chans data)
      (let ((audio-fd (mus-audio-open-output mus-audio-default (mus-sound-srate file) chans mus-lshort bytes)))
	(do ((i 0 (+ i bufsize)))
	    ((&gt;= i frames))
	  (mus-audio-write audio-fd data bufsize)
	  (mus-sound-read sound-fd 0 (1- bufsize) chans data))
	(mus-sound-close-input sound-fd)
	(mus-audio-close audio-fd)))))
</pre>
<p>You can load sndlib into the standard Guile interpreter:
</p>
<pre>
guile&gt; (define lib (<em class=red>dynamic-link</em> "/home/bil/sndlib/sndlib.so"))
guile&gt; (<em class=red>dynamic-call</em> "mus_sndlib2xen_initialize" lib)
guile&gt; (mus-sound-srate "/home/bil/cl/oboe.snd")
22050
guile&gt; (<em class=red>dynamic-call</em> "mus_xen_init" lib)
guile&gt; (define osc (make-oscil 440))
guile&gt; (oscil osc)
0.0
</pre>
<p>The first dynamic-call (mus_sndlib2xen_initialize) ties sndlib2xen.c into
Guile, and the second (mus_xen_init) ties clm2xen.c into Guile.
I've included sndlib.i in the sndlib tarfile, intended for use with
swig.  I was able to create a python wrapper, but don't know enough
(i.e. anything at all) about python.  Presumably, we could 
use this to import sndlib into a number of environments.
</p>

<br>
<span class=box><h2><A NAME="sndlibcl">Sndlib and Common Lisp</a></h2></span>

<p>
sndlib2clm.lisp imports most of the sndlib names into acl and cmucl; ffi.lisp in the
clm package has some support for mcl.  (sndlib2clm.lisp was translated from sndlib.h semi-automatically,
and has only been spot-checked to date).
</p>

<center>
<span class=htmlbox>related documentation</span><span class=htmlbox><a href="snd.html">snd.html</a><spacer type=horizontal size=25><a href="extsnd.html">extsnd.html</a><spacer type=horizontal size=25><a href="grfsnd.html">grfsnd.html</a><spacer type=horizontal size=25><a href="clm.html">clm.html</a><spacer type=horizontal size=25><a href="sndscm.html">sndscm.html</a><spacer type=horizontal size=25><a href="index.html">index.html</a></span>
</center>
</body></html>
